---
phase: 01-foundation-architecture
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/index.ts
  - src/types/span.ts
  - src/types/citation.ts
  - src/types/index.ts
  - ARCHITECTURE.md
autonomous: true

must_haves:
  truths:
    - "TypeScript compiler recognizes Span interface with clean and original position fields"
    - "Citation types use discriminated unions (no instanceof checks needed)"
    - "Position tracking architecture is documented for Phase 2-3 implementation"
  artifacts:
    - path: "src/types/span.ts"
      provides: "Position tracking interface"
      exports: ["Span"]
      contains: "cleanStart, cleanEnd, originalStart, originalEnd"
    - path: "src/types/citation.ts"
      provides: "Citation type discriminated unions"
      exports: ["Citation", "FullCaseCitation", "CitationType"]
      contains: 'type: "case"'
    - path: "src/index.ts"
      provides: "Public API entry point"
      min_lines: 5
    - path: "ARCHITECTURE.md"
      provides: "Position tracking and tree-shaking architecture documentation"
      min_lines: 50
  key_links:
    - from: "src/index.ts"
      to: "src/types/index.ts"
      via: "Type re-exports"
      pattern: 'export .* from "./types"'
    - from: "src/types/citation.ts"
      to: "src/types/span.ts"
      via: "Citation interfaces use Span type"
      pattern: "span: Span"
---

<objective>
Create foundational type system and project structure with position tracking architecture that prevents offset drift.

Purpose: Establish the Span interface for position tracking (prevents Pitfall #1 - position offset drift), discriminated union Citation types (DX-01/DX-02), and document architectural patterns for Phase 2-3 implementation. These types are the contract for all future parsing work.

Output: Type definitions in src/types/, minimal src/index.ts entry point, and ARCHITECTURE.md documenting position tracking and tree-shaking strategies.
</objective>

<execution_context>
@/Users/medelman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medelman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/medelman/GitHub/medelman17/eyecitets/.planning/PROJECT.md
@/Users/medelman/GitHub/medelman17/eyecitets/.planning/ROADMAP.md
@/Users/medelman/GitHub/medelman17/eyecitets/.planning/phases/01-foundation-architecture/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Create Span interface for position offset tracking</name>
  <files>src/types/span.ts</files>
  <action>
Create src/types/span.ts with position tracking interface (from RESEARCH.md Pattern 1):
```typescript
/**
 * Represents a text span with positions tracked through transformations.
 *
 * During text cleaning (HTML removal, whitespace normalization), positions
 * shift. Span tracks BOTH cleaned positions (for parsing) and original
 * positions (for user-facing results).
 *
 * @example
 * const original = "Smith v. Doe, 500 F.2d 123 (2020)"
 * // After cleaning, positions may shift
 * const span: Span = {
 *   cleanStart: 14,  // Position in cleaned text
 *   cleanEnd: 27,
 *   originalStart: 14,  // Position in original text
 *   originalEnd: 27
 * }
 */
export interface Span {
  /** Start position in cleaned/tokenized text (used during parsing) */
  cleanStart: number

  /** End position in cleaned/tokenized text (used during parsing) */
  cleanEnd: number

  /** Start position in original input text (returned to user) */
  originalStart: number

  /** End position in original input text (returned to user) */
  originalEnd: number
}

/**
 * Maps positions between cleaned and original text.
 *
 * Built during text transformation to track how character positions shift
 * when HTML entities are removed, whitespace is normalized, etc.
 */
export interface TransformationMap {
  /** Maps cleaned text position to original text position */
  cleanToOriginal: Map<number, number>

  /** Maps original text position to cleaned text position */
  originalToClean: Map<number, number>
}
```

This interface is CRITICAL - it prevents Pitfall #1 (position offset drift). All citation extraction will use these types. Implementation of transformation logic happens in Phase 2 (clean layer), but the interface contract is locked now.
  </action>
  <verify>cat src/types/span.ts | grep -E 'interface Span|cleanStart.*number|originalStart.*number|TransformationMap'</verify>
  <done>src/types/span.ts exists with Span interface containing cleanStart, cleanEnd, originalStart, originalEnd fields and TransformationMap interface</done>
</task>

<task type="auto">
  <name>Create discriminated union Citation types</name>
  <files>src/types/citation.ts</files>
  <action>
Create src/types/citation.ts with discriminated union citation types (from RESEARCH.md Pattern 3):
```typescript
import type { Span } from "./span"

/**
 * Citation type discriminator for type-safe pattern matching.
 */
export type CitationType = "case" | "statute" | "journal" | "shortForm" | "id" | "supra"

/**
 * Base fields shared by all citation types.
 */
export interface CitationBase {
  /** Original matched text */
  text: string

  /** Position span in document (originalStart/End point to original text) */
  span: Span
}

/**
 * Full case citation (volume-reporter-page format).
 *
 * @example "500 F.2d 123"
 * @example "410 U.S. 113, 115"
 */
export interface FullCaseCitation extends CitationBase {
  type: "case"
  volume: number
  reporter: string
  page: number
  pincite?: number
  court?: string
  year?: number
}

/**
 * Statute citation (U.S. Code, state codes, etc.).
 *
 * @example "42 U.S.C. § 1983"
 */
export interface StatuteCitation extends CitationBase {
  type: "statute"
  title?: number
  code: string
  section: string
}

/**
 * Id. citation (refers to immediately preceding citation).
 *
 * @example "Id."
 * @example "Id. at 125"
 */
export interface IdCitation extends CitationBase {
  type: "id"
  pincite?: number
}

/**
 * Union type of all citation types.
 *
 * Use type guards via discriminated union:
 * @example
 * if (citation.type === "case") {
 *   console.log(citation.volume) // TypeScript knows this exists
 * }
 */
export type Citation = FullCaseCitation | StatuteCitation | IdCitation
```

Why discriminated unions: TypeScript enforces type safety at compile time (no instanceof, no type guards, satisfies DX-01/DX-02). Switch statements on citation.type are exhaustively checked.

Note: Only 3 citation types defined here (case, statute, id). Others (journal, supra, shortForm) will be added in Phase 2/4 as needed. Starting minimal prevents over-engineering.
  </action>
  <verify>cat src/types/citation.ts | grep -E 'type CitationType|interface FullCaseCitation|type Citation ='</verify>
  <done>src/types/citation.ts exists with CitationType discriminator, CitationBase, FullCaseCitation, StatuteCitation, IdCitation, and Citation union type</done>
</task>

<task type="auto">
  <name>Create project structure and public API entry point</name>
  <files>src/index.ts, src/types/index.ts, ARCHITECTURE.md</files>
  <action>
1. Create src/types/index.ts to re-export all types:
```typescript
export type { Span, TransformationMap } from "./span"
export type { Citation, CitationType, CitationBase, FullCaseCitation, StatuteCitation, IdCitation } from "./citation"
```

2. Create src/index.ts as minimal entry point:
```typescript
/**
 * eyecite-ts: TypeScript legal citation extraction library
 *
 * Port of Python eyecite with zero dependencies, browser compatibility,
 * and <50KB gzipped bundle size.
 *
 * @packageDocumentation
 */

// Public type exports
export type { Span, TransformationMap, Citation, CitationType, CitationBase, FullCaseCitation, StatuteCitation, IdCitation } from "./types"

// Parser exports (Phase 2)
// export { extract } from "./extract"

// Annotation exports (Phase 3)
// export { annotate } from "./annotate"

// Resolution exports (Phase 4)
// export { resolve } from "./resolve"
```

3. Create ARCHITECTURE.md documenting position tracking and tree-shaking:
```markdown
# Architecture: eyecite-ts

## Overview

eyecite-ts is a zero-dependency TypeScript library for legal citation extraction. The architecture prioritizes:
1. **Position accuracy** — Citations point to correct original text positions
2. **Bundle size** — <50KB gzipped via tree-shaking
3. **Type safety** — Strict TypeScript, no `any` in public API
4. **Cross-platform** — Node.js 18+ and modern browsers

## Position Tracking Architecture

### The Problem

Text transformations (HTML cleaning, whitespace normalization) shift character positions:
- `"&nbsp;"` (6 chars) → `" "` (1 char) = 5-character shift
- Removing `<tag>` shifts all subsequent positions left
- Unicode normalization may expand/contract characters

If we parse cleaned text but return original positions, citations point to wrong locations.

### The Solution: Dual Position Tracking

Every citation tracks BOTH cleaned and original positions via `Span` interface:

```typescript
interface Span {
  cleanStart: number    // Position in cleaned text (parsing)
  cleanEnd: number
  originalStart: number // Position in original text (user-facing)
  originalEnd: number
}
```

During text cleaning, we build a `TransformationMap`:
```typescript
interface TransformationMap {
  cleanToOriginal: Map<number, number>
  originalToClean: Map<number, number>
}
```

**Workflow:**
1. User provides original text
2. Cleaner transforms text → cleaned text + TransformationMap
3. Parser extracts citations from cleaned text → Span with cleanStart/cleanEnd
4. Before returning, map clean positions to original positions
5. User receives citations with originalStart/originalEnd pointing to correct text

**Implementation notes:**
- Span interface defined in Phase 1 (this phase)
- TransformationMap building in Phase 2 (clean layer)
- Position mapping logic in Phase 2 (extract layer)
- Validation with 100+ real documents in Phase 3/4

## Tree-Shaking Strategy

### The Problem

Full reporters-db is ~200-400KB uncompressed, 50-100KB gzipped. Including all 1200+ reporters in every bundle violates <50KB constraint.

### The Solution: Named Exports + sideEffects: false

**Database structure:**
```typescript
// src/data/reporters.ts
export const F_REPORTER = { abbreviation: "F.", jurisdiction: "Federal", ... }
export const F2D_REPORTER = { abbreviation: "F.2d", ... }
export const F3D_REPORTER = { abbreviation: "F.3d", ... }
// ... 1197 more
```

**Consumer usage:**
```typescript
import { F_REPORTER, F2D_REPORTER } from "eyecite-ts/data"
// Bundler eliminates 1198 unused reporters
```

**Configuration:**
- package.json: `"sideEffects": false`
- tsdown: minify + tree-shaking enabled
- Conditional exports with subpath `./data`

**Result:** Users importing 10 reporters get ~10KB bundle, not 50KB.

## Type System Design

### Discriminated Union Citations

All citation types use discriminated unions for type-safe pattern matching:

```typescript
type Citation = FullCaseCitation | StatuteCitation | IdCitation

function handle(citation: Citation) {
  switch (citation.type) {
    case "case":
      return citation.volume // TypeScript knows this exists
    case "statute":
      return citation.section
    case "id":
      return "Id."
  }
  // TypeScript ensures all cases handled
}
```

**Benefits:**
- Compile-time type checking (no runtime instanceof)
- Exhaustiveness checking (compiler error if case missing)
- Zero `any` types in public API (DX-01, DX-02)

## Parsing Pipeline

```
Original Text
    ↓
┌────────────────┐
│ Clean Layer    │ → cleaned text + TransformationMap
│ (Phase 2)      │
└────────────────┘
    ↓
┌────────────────┐
│ Tokenize Layer │ → tokens with cleanStart/cleanEnd
│ (Phase 2)      │
└────────────────┘
    ↓
┌────────────────┐
│ Extract Layer  │ → citations with cleanStart/cleanEnd
│ (Phase 2)      │
└────────────────┘
    ↓
┌────────────────┐
│ Position Map   │ → citations with originalStart/originalEnd
│ (Phase 2)      │
└────────────────┘
    ↓
User receives Citation[]
```

**Layer isolation:**
- Each layer in separate directory: clean/, tokenize/, extract/, annotate/, resolve/
- Each layer exports via index.ts for modularity
- No circular dependencies

## Build Configuration

### TypeScript (tsconfig.json)
- strict: true (all strict checks)
- isolatedDeclarations: true (fast .d.ts via oxc)
- target: ES2020 (modern regex, Node 18+)
- moduleResolution: "bundler"

### tsdown (tsdown.config.ts)
- Dual output: ESM (.mjs) + CommonJS (.cjs)
- Declaration generation: .d.ts files
- Minification enabled
- Source maps included

### package.json exports
```json
"exports": {
  ".": {
    "types": "./dist/index.d.ts",
    "import": "./dist/index.mjs",
    "require": "./dist/index.cjs"
  }
}
```
**Order matters:** "types" MUST come before "import"/"require" for TypeScript resolution.

## Testing Strategy

### Unit Tests (Phase 2+)
- Vitest with v8 coverage
- Target: 80% lines/functions/statements, 75% branches
- Per-layer tests: clean.test.ts, tokenize.test.ts, extract.test.ts

### ReDoS Testing (Phase 2)
- testTimeout: 10000ms in vitest.config.ts
- Validate all regex patterns against malicious input
- Fail if any pattern exceeds 100ms

### Position Accuracy Tests (Phase 3/4)
- Validate on 100+ real legal documents with HTML/Unicode
- Test clean→original position mapping accuracy
- Compare against Python eyecite test corpus

## References

- Research: `.planning/phases/01-foundation-architecture/01-RESEARCH.md`
- Project requirements: `.planning/PROJECT.md`
- Roadmap: `.planning/ROADMAP.md`
```

This documents the architectural decisions made in Phase 1 and guides implementation in Phases 2-4.
  </action>
  <verify>test -f src/index.ts && test -f src/types/index.ts && test -f ARCHITECTURE.md && cat ARCHITECTURE.md | wc -l | awk '{if($1 >= 50) print "pass"; else print "fail"}'</verify>
  <done>src/index.ts, src/types/index.ts, and ARCHITECTURE.md exist; ARCHITECTURE.md is at least 50 lines documenting position tracking and tree-shaking strategies</done>
</task>

</tasks>

<verification>
Run these checks after all tasks complete:
1. `ls -la src/types/` lists span.ts, citation.ts, index.ts
2. `cat src/types/span.ts | grep 'interface Span'` confirms Span interface exists
3. `cat src/types/citation.ts | grep 'type Citation ='` confirms discriminated union
4. `cat src/index.ts | grep 'export type'` confirms type re-exports
5. `cat ARCHITECTURE.md | grep -i 'position tracking'` confirms documentation
6. `npx tsc --noEmit` passes (no type errors)
</verification>

<success_criteria>
Type system and structure complete when:
- Span interface exists with dual position tracking (cleanStart/End, originalStart/End)
- Citation types use discriminated unions (type: "case" | "statute" | "id")
- TransformationMap interface documented for Phase 2 implementation
- src/index.ts entry point exists with type re-exports
- ARCHITECTURE.md documents position tracking and tree-shaking strategies (50+ lines)
- TypeScript compiler validates all types without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-architecture/01-03-SUMMARY.md`
</output>
