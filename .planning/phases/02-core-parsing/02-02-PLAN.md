---
phase: 02-core-parsing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/patterns/casePatterns.ts
  - src/patterns/statutePatterns.ts
  - src/patterns/journalPatterns.ts
  - src/patterns/neutralPatterns.ts
  - src/patterns/index.ts
  - tests/patterns/redos.test.ts
autonomous: true

must_haves:
  truths:
    - "Regex patterns detect case citations (volume-reporter-page format)"
    - "Regex patterns detect statute citations (code section format)"
    - "Regex patterns detect journal and neutral citations"
    - "No pattern triggers >100ms parse time (ReDoS protection validated)"
  artifacts:
    - path: "src/patterns/casePatterns.ts"
      provides: "Regex patterns for case citations"
      exports: ["casePatterns"]
    - path: "src/patterns/statutePatterns.ts"
      provides: "Regex patterns for statute citations"
      exports: ["statutePatterns"]
    - path: "tests/patterns/redos.test.ts"
      provides: "ReDoS timeout validation"
      min_lines: 30
  key_links:
    - from: "tests/patterns/redos.test.ts"
      to: "src/patterns/*.ts"
      via: "Pattern import and timeout testing"
      pattern: "import.*Patterns.*from"
---

<objective>
Define regex patterns for all citation types (case, statute, journal, neutral, public law, Federal Register) with ReDoS protection. Patterns are designed for tokenization (broad matching) not extraction (metadata parsing happens in Phase 2 Plan 5).

Purpose: Establishes pattern library for tokenizer (Plan 3) with performance guarantees
Output: Pattern definitions, ReDoS validation tests
</objective>

<execution_context>
@/Users/medelman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medelman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-parsing/02-CONTEXT.md
@.planning/phases/02-core-parsing/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create case citation regex patterns</name>
  <files>src/patterns/casePatterns.ts, src/patterns/index.ts</files>
  <action>
Create `src/patterns/casePatterns.ts` with regex patterns for case citations:

```typescript
export interface Pattern {
  id: string
  regex: RegExp
  description: string
  type: 'case' | 'statute' | 'journal' | 'neutral' | 'publicLaw' | 'federalRegister'
}

export const casePatterns: Pattern[] = [
  {
    id: 'federal-reporter',
    regex: /\b(\d+)\s+(F\.|F\.2d|F\.3d|F\.\s?Supp\.|F\.\s?Supp\.\s?2d|F\.\s?Supp\.\s?3d)\s+(\d+)\b/g,
    description: 'Federal Reporter (F., F.2d, F.3d, F.Supp., etc.)',
    type: 'case',
  },
  {
    id: 'supreme-court',
    regex: /\b(\d+)\s+(U\.S\.|S\.\s?Ct\.|L\.\s?Ed\.(?:\s?2d)?)\s+(\d+)\b/g,
    description: 'U.S. Supreme Court reporters',
    type: 'case',
  },
  {
    id: 'state-reporter',
    regex: /\b(\d+)\s+([A-Z][A-Za-z\.]+(?:\s?2d|\s?3d)?)\s+(\d+)\b/g,
    description: 'State reporters (broad pattern, validated against reporters-db in Phase 3)',
    type: 'case',
  },
]
```

**Pattern design principles (from RESEARCH.md):**
- Use `\b` word boundaries to avoid matching "F." in "F.B.I."
- Avoid nested quantifiers: `(a+)+` causes ReDoS
- Keep patterns simple: tokenization only needs to find candidates, not parse metadata
- Use global flag `/g` for matchAll()

Create `src/patterns/index.ts` with re-exports:
```typescript
export * from './casePatterns'
// Future exports will be added here as Task 2 creates additional pattern files
```

**Re-export strategy:** `src/patterns/index.ts` re-exports individual named arrays (casePatterns, statutePatterns, journalPatterns, neutralPatterns) so consumers can import specific pattern sets or all patterns.

Add JSDoc comment explaining that patterns are for tokenization (broad matching) and will be validated against reporters-db in Phase 3.
  </action>
  <verify>
Run `npm run typecheck` - no errors
Check that Pattern interface and casePatterns are exported
Verify patterns compile as valid RegExp
  </verify>
  <done>Case citation patterns defined with ReDoS-safe regex, exported from src/patterns/index.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create statute, journal, neutral, and law citation patterns</name>
  <files>src/patterns/statutePatterns.ts, src/patterns/journalPatterns.ts, src/patterns/neutralPatterns.ts, src/patterns/index.ts</files>
  <action>
Create `src/patterns/statutePatterns.ts` with patterns:
- U.S. Code: `\b(\d+)\s+U\.S\.C\.?\s+ยง+\s*(\d+)\b`
- State codes: `\b([A-Z][a-z]+\.?\s+[A-Za-z\.]+\s+Code)\s+ยง\s*(\d+)\b` (broad pattern)

Create `src/patterns/journalPatterns.ts` with patterns:
- Law review: `\b(\d+)\s+([A-Z][A-Za-z\.\s]+)\s+(\d+)\b` (validated against journals-db in Phase 3)

Create `src/patterns/neutralPatterns.ts` with patterns:
- WestLaw: `\b(\d{4})\s+WL\s+(\d+)\b`
- LexisNexis: `\b(\d{4})\s+U\.S\.\s+LEXIS\s+(\d+)\b`
- Public law: `\bPub\.\s?L\.\s?No\.\s?(\d+-\d+)\b`
- Federal Register: `\b(\d+)\s+Fed\.\s?Reg\.\s+(\d+)\b`

All patterns follow same structure as casePatterns (Pattern interface). Add JSDoc explaining purpose.

Update `src/patterns/index.ts` to re-export all pattern files:
```typescript
export * from './casePatterns'
export * from './statutePatterns'
export * from './journalPatterns'
export * from './neutralPatterns'
```

This allows consumers to:
- Import specific sets: `import { casePatterns, statutePatterns } from '@/patterns'`
- Import all patterns: `import { casePatterns, statutePatterns, journalPatterns, neutralPatterns } from '@/patterns'`

**Pattern notes:**
- These are intentionally broad - false positives are acceptable for tokenization
- Extraction layer (Plan 5) will validate against reporters-db/journals-db
- ReDoS protection comes from simple structure (no nested quantifiers)
  </action>
  <verify>
Run `npm run typecheck` - no errors
Check that all pattern arrays (casePatterns, statutePatterns, journalPatterns, neutralPatterns) are exported from src/patterns/index.ts
Manually test one pattern from each file with regex101.com (paste, verify no ReDoS warnings)
  </verify>
  <done>All citation type patterns defined (statute, journal, neutral, public law, federal register) with ReDoS-safe regex, re-exported as individual named arrays from src/patterns/index.ts</done>
</task>

<task type="auto">
  <name>Task 3: Create ReDoS timeout validation tests</name>
  <files>tests/patterns/redos.test.ts</files>
  <action>
Create `tests/patterns/redos.test.ts` with Vitest tests validating that no pattern triggers ReDoS on malformed input:

```typescript
import { describe, it, expect } from 'vitest'
import { casePatterns, statutePatterns, journalPatterns, neutralPatterns } from '@/patterns'

describe('ReDoS protection', () => {
  const allPatterns = [
    ...casePatterns,
    ...statutePatterns,
    ...journalPatterns,
    ...neutralPatterns,
  ]

  // Malformed inputs that could trigger catastrophic backtracking
  const malformedInputs = [
    'Smith v. Doe, 500 F.2d 123 ('.repeat(100), // Missing closing paren
    '123 '.repeat(1000) + 'U.S. 456', // Excessive numbers
    'a'.repeat(10000), // Long non-matching text
    '((((('.repeat(100) + '123 F.2d 456', // Nested parens
  ]

  for (const pattern of allPatterns) {
    it(`should not timeout on malformed input: ${pattern.id}`, () => {
      const startTime = Date.now()

      for (const input of malformedInputs) {
        const matches = [...input.matchAll(pattern.regex)]
        // We don't care about results, just that it completes
      }

      const duration = Date.now() - startTime
      expect(duration).toBeLessThan(100) // <100ms per pattern (PERF requirement)
    }, { timeout: 500 }) // Vitest test timeout (not pattern timeout)
  })
})
```

Tests verify that even on pathological input, patterns complete in <100ms total (across all malformed inputs).

Use Vitest's `{ timeout: 500 }` option to fail test if it exceeds 500ms (indicates ReDoS).

Add test for each pattern individually with descriptive names.
  </action>
  <verify>
Run `npm test tests/patterns/redos.test.ts` - all tests pass
No test takes >100ms (check Vitest duration output)
All patterns tested against malformed input
  </verify>
  <done>ReDoS protection validated for all patterns on malformed input, <100ms parse time guaranteed</done>
</task>

</tasks>

<verification>
1. Run `npm run typecheck` - no TypeScript errors
2. Run `npm test tests/patterns/` - all pattern tests pass
3. Verify all pattern files export Pattern[] arrays with correct names (casePatterns, statutePatterns, journalPatterns, neutralPatterns)
4. Check that ReDoS tests complete in <100ms per pattern
5. Manually spot-check 2-3 patterns on regex101.com for ReDoS warnings
</verification>

<success_criteria>
- All citation types have regex patterns (case, statute, journal, neutral, public law, federal register)
- Patterns use simple structure (no nested quantifiers)
- ReDoS tests validate <100ms parse time on malformed input
- All patterns exported from src/patterns/index.ts as individual named arrays
- Pattern interface is reusable for tokenization layer
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-parsing/02-02-SUMMARY.md`
</output>
