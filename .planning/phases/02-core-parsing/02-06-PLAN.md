---
phase: 02-core-parsing
plan: 06
type: execute
wave: 4
depends_on: [02-01, 02-03, 02-05]
files_modified:
  - src/extract/extractCitations.ts
  - src/index.ts
  - tests/extract/extractCitations.test.ts
  - tests/integration/fullPipeline.test.ts
autonomous: true

must_haves:
  truths:
    - "Developer can call extractCitations(text) and receive all citations from text"
    - "Pipeline executes clean → tokenize → extract → translate in sequence"
    - "Both sync and async APIs are available"
    - "Integration tests validate full pipeline on real legal text"
  artifacts:
    - path: "src/extract/extractCitations.ts"
      provides: "Main extraction pipeline"
      exports: ["extractCitations", "extractCitationsAsync"]
      min_lines: 80
    - path: "src/index.ts"
      provides: "Public API entry point"
      contains: "extractCitations"
    - path: "tests/integration/fullPipeline.test.ts"
      provides: "End-to-end pipeline validation"
      min_lines: 60
  key_links:
    - from: "src/extract/extractCitations.ts"
      to: "src/clean/cleanText.ts"
      via: "Text cleaning"
      pattern: "import.*cleanText.*from.*clean"
    - from: "src/extract/extractCitations.ts"
      to: "src/tokenize/tokenizer.ts"
      via: "Tokenization"
      pattern: "import.*tokenize.*from.*tokenize"
    - from: "src/extract/extractCitations.ts"
      to: "src/extract/extractCase.ts"
      via: "Citation extraction routing"
      pattern: "import.*extract.*from"
---

<objective>
Implement main extraction pipeline that orchestrates clean → tokenize → extract → translate layers. Provides public API (extractCitations, extractCitationsAsync) with integration tests validating full pipeline on legal text samples.

Purpose: Completes Phase 2 core parsing engine with public-facing API
Output: Main pipeline, public API exports, integration tests
</objective>

<execution_context>
@/Users/medelman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medelman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-parsing/02-CONTEXT.md
@.planning/phases/02-core-parsing/02-RESEARCH.md
@.planning/phases/02-core-parsing/02-01-SUMMARY.md
@.planning/phases/02-core-parsing/02-03-SUMMARY.md
@.planning/phases/02-core-parsing/02-05-SUMMARY.md
@src/clean/index.ts
@src/tokenize/index.ts
@src/extract/index.ts
@src/types/citation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement extractCitations pipeline (sync and async)</name>
  <files>src/extract/extractCitations.ts</files>
  <action>
Create `src/extract/extractCitations.ts` with main extraction pipeline:

```typescript
import { cleanText } from '@/clean'
import { tokenize } from '@/tokenize'
import { extractCase, extractStatute, extractJournal, extractNeutral, extractPublicLaw, extractFederalRegister } from '@/extract'
import { casePatterns, statutePatterns, journalPatterns, neutralPatterns } from '@/patterns'
import type { Citation } from '@/types/citation'

export interface ExtractOptions {
  /** Custom text cleaners (overrides defaults) */
  cleaners?: Array<(text: string) => string>
  /** Custom regex patterns (overrides defaults) */
  patterns?: Pattern[]
}

export function extractCitations(
  text: string,
  options?: ExtractOptions
): Citation[] {
  const startTime = performance.now()

  // Step 1: Clean text
  const { cleaned, transformationMap, warnings } = cleanText(
    text,
    options?.cleaners
  )

  // Step 2: Tokenize (synchronous)
  const allPatterns = options?.patterns || [
    ...casePatterns,
    ...statutePatterns,
    ...journalPatterns,
    ...neutralPatterns,
  ]
  const tokens = tokenize(cleaned, allPatterns)

  // Step 3: Extract citations from tokens
  const citations: Citation[] = []
  for (const token of tokens) {
    let citation: Citation

    switch (token.type) {
      case 'case':
        citation = extractCase(token, transformationMap)
        break
      case 'statute':
        citation = extractStatute(token, transformationMap)
        break
      case 'journal':
        citation = extractJournal(token, transformationMap)
        break
      case 'neutral':
        citation = extractNeutral(token, transformationMap)
        break
      case 'publicLaw':
        citation = extractPublicLaw(token, transformationMap)
        break
      case 'federalRegister':
        citation = extractFederalRegister(token, transformationMap)
        break
      default:
        // Unknown type - skip
        continue
    }

    // Attach cleaning warnings to citation if any
    if (warnings.length > 0) {
      citation.warnings = [...(citation.warnings || []), ...warnings]
    }

    // Update processing time
    citation.processTimeMs = performance.now() - startTime

    citations.push(citation)
  }

  return citations
}

export async function extractCitationsAsync(
  text: string,
  options?: ExtractOptions
): Promise<Citation[]> {
  // Async wrapper for future extensibility (e.g., async reporters-db lookup)
  // For MVP, wraps synchronous extractCitations
  return extractCitations(text, options)
}
```

Implementation notes:
- Pipeline executes layers in sequence: clean → tokenize → extract
- TransformationMap is built during clean, passed to extract for position translation
- Switch statement routes tokens to appropriate extraction function (type-safe via discriminated union)
- Options allow custom cleaners and patterns (extensibility from CONTEXT.md)
- Warnings from cleaning layer are attached to citations
- ProcessTimeMs tracks total pipeline duration per citation
- Both sync (extractCitations) and async (extractCitationsAsync) variants available per CONTEXT.md decision

Add JSDoc explaining pipeline flow and options.

Update `src/extract/index.ts` to re-export extractCitations and extractCitationsAsync.
  </action>
  <verify>
Run `npm run typecheck` - no errors
Check that both extractCitations and extractCitationsAsync are exported
Verify pipeline compiles and type-checks correctly
  </verify>
  <done>extractCitations() and extractCitationsAsync() pipelines orchestrate clean → tokenize → extract layers</done>
</task>

<task type="auto">
  <name>Task 2: Export public API from src/index.ts</name>
  <files>src/index.ts</files>
  <action>
Update `src/index.ts` to export Phase 2 functions:

```typescript
// Types (from Phase 1)
export type {
  Span,
  TransformationMap,
  Citation,
  CitationType,
  CitationBase,
  FullCaseCitation,
  StatuteCitation,
  JournalCitation,
  NeutralCitation,
  PublicLawCitation,
  FederalRegisterCitation,
  IdCitation,
} from './types'

// Main API (Phase 2)
export { extractCitations, extractCitationsAsync } from './extract/extractCitations'
export type { ExtractOptions } from './extract/extractCitations'

// Granular APIs (Phase 2 - for power users)
export { cleanText } from './clean'
export type { CleanTextResult, Warning } from './clean/cleanText'

export { tokenize } from './tokenize'
export type { Token } from './tokenize/tokenizer'

// Extraction functions (for advanced use cases)
export {
  extractCase,
  extractStatute,
  extractJournal,
  extractNeutral,
  extractPublicLaw,
  extractFederalRegister,
} from './extract'
```

This provides:
1. **Convenience API:** extractCitations(text) and extractCitationsAsync(text) for most users
2. **Granular APIs:** cleanText, tokenize, extractCase, etc. for power users who need pipeline control
3. **Types:** All citation types and interfaces for TypeScript consumers

Remove placeholder comments from Phase 1 (replace with actual exports).

Add JSDoc comment at top of file explaining the three API tiers (convenience, granular, types).
  </action>
  <verify>
Run `npm run typecheck` - no errors
Check that all exports are valid (no missing imports)
Verify TypeScript can import from package: `import { extractCitations } from 'eyecite-ts'`
  </verify>
  <done>Public API exports convenience and granular functions for citation extraction</done>
</task>

<task type="auto">
  <name>Task 3: Create integration tests for full pipeline</name>
  <files>tests/integration/fullPipeline.test.ts</files>
  <action>
Create `tests/integration/fullPipeline.test.ts` with end-to-end tests on real legal text:

**Test 1: Extract from clean text (no HTML)**
- Input: "In Smith v. Doe, 500 F.2d 123 (9th Cir. 2020), the court held..."
- Expected: 1 citation (case), metadata: { volume: 500, reporter: "F.2d", page: 123, court: "9th Cir.", year: 2020 }
- Assert: Citation found, metadata correct, positions point to "500 F.2d 123" in original

**Test 2: Extract from HTML-heavy text**
- Input: "<p>In <b>Smith v. Doe</b>, 500 F.2d 123, the court...</p>"
- Expected: 1 citation (case)
- Assert: Citation found after HTML stripping, originalSpan points to correct position in original HTML

**Test 3: Extract multiple citation types**
- Input: "See 42 U.S.C. § 1983; Smith v. Doe, 500 F.2d 123; 123 Harv. L. Rev. 456"
- Expected: 3 citations (statute, case, journal)
- Assert: All three found, correct types, correct metadata

**Test 4: Extract with position accuracy (ASCII only)**
- Input: "The case Smith v. Doe, 500 F.2d 123, established..."
- Expected: Citation at positions [23, 36] in cleaned text
- Assert: `original.substring(citation.span.originalStart, citation.span.originalEnd)` === "500 F.2d 123"
- **Note:** Complex Unicode position tracking deferred to Phase 3 per Plan 01 limitation

**Test 5: Extract from complex legal text (realistic)**
- Input: Real Supreme Court opinion snippet (100+ words with multiple citations)
- Expected: Multiple citations with correct metadata
- Assert: All citations found, no false positives, confidence scores reasonable

**Test 6: Handle text with no citations**
- Input: "This is plain text with no legal citations at all."
- Expected: Empty array
- Assert: citations.length === 0

**Test 7: Custom cleaners**
- Input: "Smith v. Doe, 500 F.2d 123" with custom cleaner that uppercases
- Expected: Citation still found (case-insensitive matching)
- Assert: Citation metadata extracted correctly

**Test 8: Async API equivalence**
- Input: Same as Test 1
- Use `await extractCitationsAsync(input)` instead of `extractCitations(input)`
- Assert: Results identical to sync version

Use `extractCitations(input)` and `await extractCitationsAsync(input)` for tests. Add descriptive test names.

Include sample legal text strings as constants at top of file for readability.
  </action>
  <verify>
Run `npm test tests/integration/fullPipeline.test.ts` - all tests pass
Verify pipeline produces correct citations on realistic legal text
Check that position accuracy test passes (ASCII-only, Unicode deferred to Phase 3)
Verify both sync and async APIs produce identical results
  </verify>
  <done>Integration tests validate full pipeline on legal text, including position accuracy (ASCII) and multiple citation types, confirming both sync and async APIs work</done>
</task>

</tasks>

<verification>
1. Run `npm run typecheck` - no TypeScript errors
2. Run `npm test tests/integration/` - all pipeline tests pass
3. Check that both extractCitations and extractCitationsAsync are exported from src/index.ts
4. Verify full pipeline executes: clean → tokenize → extract → translate
5. Test on realistic legal text sample (copy from court opinion)
6. Verify position accuracy: original.substring(span.original) matches citation text (ASCII-only for MVP)
7. Verify both sync and async APIs produce identical results
</verification>

<success_criteria>
- Developer can call extractCitations(text) or extractCitationsAsync(text) and receive all citations
- Pipeline executes clean → tokenize → extract → translate in sequence
- Both sync and async APIs available and produce identical results
- Public API exports convenience and granular functions
- Integration tests validate on realistic legal text samples
- Position tracking is accurate for ASCII text (complex Unicode deferred to Phase 3)
- All code compiles with TypeScript strict mode
- Phase 2 requirements (DET-01 through DET-22, META-01 through META-08, CLN-01 through CLN-06) are satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-parsing/02-06-SUMMARY.md`
</output>
