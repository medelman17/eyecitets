---
phase: 04-short-form-resolution
plan: 03
type: execute
wave: 2
depends_on: [04-01]
files_modified:
  - src/resolve/types.ts
  - src/resolve/DocumentResolver.ts
  - src/resolve/scopeBoundary.ts
  - src/resolve/levenshtein.ts
  - src/resolve/index.ts
  - tests/unit/resolve/scopeBoundary.test.ts
  - tests/unit/resolve/levenshtein.test.ts
autonomous: true

must_haves:
  truths:
    - "DocumentResolver processes citations sequentially maintaining antecedent history"
    - "Id. resolves to immediately preceding full citation"
    - "Supra resolves to full citation with matching party name"
    - "Short-form case resolves to full case with matching volume/reporter"
    - "Paragraph boundaries detected from text (double newline default)"
    - "Scope boundary configurable (paragraph, section, footnote, none)"
    - "Resolution returns immutable results with resolution field"
    - "resolveCitations wrapper function provides convenient API"
  artifacts:
    - path: "src/resolve/types.ts"
      provides: "ResolutionOptions, ResolutionResult, ResolutionContext interfaces"
      exports: ["ResolutionOptions", "ResolutionResult", "ResolvedCitation"]
    - path: "src/resolve/DocumentResolver.ts"
      provides: "Document-scoped resolver instance with state tracking"
      exports: ["DocumentResolver"]
      min_lines: 250
    - path: "src/resolve/scopeBoundary.ts"
      provides: "Paragraph boundary detection and scope validation"
      exports: ["detectParagraphBoundaries", "isWithinBoundary"]
    - path: "src/resolve/levenshtein.ts"
      provides: "Levenshtein distance calculation for party name matching"
      exports: ["levenshteinDistance", "normalizedLevenshteinDistance"]
    - path: "src/resolve/index.ts"
      provides: "resolveCitations wrapper function"
      exports: ["resolveCitations", "DocumentResolver"]
    - path: "tests/unit/resolve/scopeBoundary.test.ts"
      provides: "Scope boundary detection tests"
      min_lines: 40
    - path: "tests/unit/resolve/levenshtein.test.ts"
      provides: "Levenshtein distance tests"
      min_lines: 30
  key_links:
    - from: "src/resolve/DocumentResolver.ts"
      to: "src/resolve/types.ts"
      via: "import ResolutionOptions"
      pattern: "ResolutionOptions.*ResolutionResult"
    - from: "src/resolve/DocumentResolver.ts"
      to: "src/resolve/scopeBoundary.ts"
      via: "calls detectParagraphBoundaries"
      pattern: "detectParagraphBoundaries"
    - from: "src/resolve/DocumentResolver.ts"
      to: "src/resolve/levenshtein.ts"
      via: "calls normalizedLevenshteinDistance for supra matching"
      pattern: "normalizedLevenshteinDistance"
    - from: "src/resolve/index.ts"
      to: "src/resolve/DocumentResolver.ts"
      via: "resolveCitations wrapper instantiates DocumentResolver"
      pattern: "new DocumentResolver"
---

<objective>
Implement full document-scoped resolution engine with configurable scope boundaries, Id./supra/short-form resolution algorithms, Levenshtein distance for party name matching, and convenient resolveCitations wrapper function.

Purpose: Core resolution infrastructure that tracks antecedent history, enforces scope boundaries, and resolves all short-form citation types following Bluebook rules.

Output: DocumentResolver class with complete resolution logic, scope boundary utilities, Levenshtein distance implementation, resolveCitations wrapper, comprehensive tests.
</objective>

<execution_context>
@/Users/medelman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medelman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/medelman/GitHub/medelman17/eyecitets/.planning/PROJECT.md
@/Users/medelman/GitHub/medelman17/eyecitets/.planning/ROADMAP.md
@/Users/medelman/GitHub/medelman17/eyecitets/.planning/STATE.md
@/Users/medelman/GitHub/medelman17/eyecitets/.planning/phases/04-short-form-resolution/04-CONTEXT.md
@/Users/medelman/GitHub/medelman17/eyecitets/.planning/phases/04-short-form-resolution/04-RESEARCH.md

Architecture patterns from research:
- Pattern 1: Document-Scoped Resolution State Machine
- Pattern 3: Scope Boundary Configuration
- Pattern 4: Immutable Resolution Results

Plan 01 output:
@/Users/medelman/GitHub/medelman17/eyecitets/.planning/phases/04-short-form-resolution/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create resolution type system</name>
  <files>src/resolve/types.ts</files>
  <action>
Create type definitions for resolution following RESEARCH.md Pattern 1 and Pattern 4.

```typescript
import type { Citation } from '../types'

/**
 * Resolution configuration options.
 */
export interface ResolutionOptions {
  /** Scope boundary strategy: 'paragraph' (default), 'section', 'footnote', or 'none' */
  scopeStrategy: 'paragraph' | 'section' | 'footnote' | 'none'

  /** Auto-detect paragraphs via text (true) or use caller metadata (false) */
  autoDetectParagraphs: boolean

  /** Paragraph boundary regex (default: double newline) */
  paragraphBoundaryPattern: RegExp

  /** Supra party name matching: fuzzy Levenshtein (true) or exact (false) */
  fuzzyPartyMatching: boolean

  /** Levenshtein threshold for supra match (0-1; default: 0.8) */
  partyMatchThreshold: number

  /** Allow nested resolution: Id. → supra → full (default: false) */
  allowNestedResolution: boolean

  /** Warnings for unresolved citations (default: true) */
  reportUnresolved: boolean
}

/**
 * Result of citation resolution.
 */
export interface ResolutionResult {
  /** Resolved antecedent citation, if found */
  resolvedTo?: Citation

  /** Reason resolution failed, if applicable */
  failureReason?: string

  /** Warnings/notes explaining resolution */
  warnings: Array<{
    level: 'warning' | 'info'
    message: string
  }>

  /** Confidence in resolution (0-1); absent if unresolved */
  confidence?: number
}

/**
 * Citation with resolution result attached.
 */
export interface ResolvedCitation extends Citation {
  resolution?: ResolutionResult
}

/**
 * Internal context tracked during resolution.
 */
export interface ResolutionContext {
  /** Current citation index being resolved */
  citationIndex: number

  /** All citations seen so far */
  allCitations: Citation[]

  /** Most recent full citation (for Id. resolution) */
  lastFullCitation: Citation | null

  /** Full citation history (for supra resolution) */
  fullCitationHistory: Citation[]

  /** Paragraph boundaries: citation index → paragraph number */
  paragraphMap?: Map<number, number>
}
```

Export all interfaces.
  </action>
  <verify>grep "export interface ResolutionOptions" src/resolve/types.ts returns interface definition</verify>
  <done>Resolution type system defined with options, results, and context interfaces</done>
</task>

<task type="auto">
  <name>Task 2: Implement scope boundary detection and Levenshtein distance</name>
  <files>src/resolve/scopeBoundary.ts, src/resolve/levenshtein.ts, tests/unit/resolve/scopeBoundary.test.ts, tests/unit/resolve/levenshtein.test.ts</files>
  <action>
**Part A: Implement scope boundary detection (src/resolve/scopeBoundary.ts)**

Follow RESEARCH.md Pattern 3:

```typescript
import type { Citation } from '../types'

/**
 * Detect paragraph boundaries from text.
 * Returns map: citation index → paragraph number
 */
export function detectParagraphBoundaries(
  text: string,
  citations: Citation[],
  boundaryPattern: RegExp = /\n\n+/
): Map<number, number> {
  const map = new Map<number, number>()

  // Split text by paragraph boundaries
  const paragraphs = text.split(boundaryPattern)

  // Build offset map: which paragraph contains each character position
  let currentOffset = 0
  const offsetToParagraph: Array<{ start: number; end: number; paragraph: number }> = []

  for (let i = 0; i < paragraphs.length; i++) {
    const paraLength = paragraphs[i].length
    offsetToParagraph.push({
      start: currentOffset,
      end: currentOffset + paraLength,
      paragraph: i
    })
    // Account for boundary pattern length (e.g., "\n\n" = 2 chars)
    currentOffset += paraLength + 2  // Simplified: assumes \n\n
  }

  // Map each citation to its paragraph
  for (let i = 0; i < citations.length; i++) {
    const citation = citations[i]
    const citationStart = citation.span.originalStart

    // Find which paragraph contains this citation
    const para = offsetToParagraph.find(
      p => citationStart >= p.start && citationStart < p.end
    )

    if (para) {
      map.set(i, para.paragraph)
    } else {
      // Fallback: assign to last paragraph
      map.set(i, paragraphs.length - 1)
    }
  }

  return map
}

/**
 * Check if antecedent is within scope boundary of current citation.
 */
export function isWithinBoundary(
  antecedentIndex: number,
  currentIndex: number,
  paragraphMap: Map<number, number>,
  strategy: 'paragraph' | 'section' | 'footnote' | 'none'
): boolean {
  if (strategy === 'none') return true

  const antecedentPara = paragraphMap.get(antecedentIndex)
  const currentPara = paragraphMap.get(currentIndex)

  if (antecedentPara === undefined || currentPara === undefined) {
    return true  // Fallback: allow if unknown
  }

  if (strategy === 'paragraph') {
    return antecedentPara === currentPara
  }

  if (strategy === 'section') {
    // Section = ~3 paragraphs (rough approximation)
    const sectionSize = 3
    return Math.floor(antecedentPara / sectionSize) === Math.floor(currentPara / sectionSize)
  }

  // 'footnote' requires caller metadata - not implemented in Phase 4
  return true
}
```

**Part B: Implement Levenshtein distance (src/resolve/levenshtein.ts)**

Per RES-04 requirement for party name matching:

```typescript
/**
 * Calculate Levenshtein distance between two strings.
 * Returns minimum edits (insertions, deletions, substitutions) to transform a into b.
 */
export function levenshteinDistance(a: string, b: string): number {
  const matrix: number[][] = []

  // Initialize matrix
  for (let i = 0; i <= a.length; i++) {
    matrix[i] = [i]
  }
  for (let j = 0; j <= b.length; j++) {
    matrix[0][j] = j
  }

  // Fill matrix
  for (let i = 1; i <= a.length; i++) {
    for (let j = 1; j <= b.length; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1
      matrix[i][j] = Math.min(
        matrix[i - 1][j] + 1,       // deletion
        matrix[i][j - 1] + 1,       // insertion
        matrix[i - 1][j - 1] + cost // substitution
      )
    }
  }

  return matrix[a.length][b.length]
}

/**
 * Calculate normalized Levenshtein distance (0-1).
 * 0 = identical, 1 = completely different.
 * Returns 1 - (distance / maxLength) for similarity scoring.
 */
export function normalizedLevenshteinDistance(a: string, b: string): number {
  const distance = levenshteinDistance(a.toLowerCase(), b.toLowerCase())
  const maxLength = Math.max(a.length, b.length)

  if (maxLength === 0) return 1.0  // Both empty strings = identical

  return 1 - (distance / maxLength)
}
```

**Part C: Create tests (tests/unit/resolve/scopeBoundary.test.ts)**

```typescript
import { describe, it, expect } from 'vitest'
import { detectParagraphBoundaries, isWithinBoundary } from '@/resolve/scopeBoundary'
import type { Citation, Span } from '@/types'

const createMockCitation = (start: number, end: number): Citation => ({
  type: 'case',
  text: 'test',
  span: { cleanStart: start, cleanEnd: end, originalStart: start, originalEnd: end },
  volume: 500,
  reporter: 'F.2d',
  page: 123,
  confidence: 1.0,
  matchedText: 'test',
  processTimeMs: 0,
  patternsChecked: 1
})

describe('detectParagraphBoundaries', () => {
  it('detects paragraphs separated by double newline', () => {
    const text = 'Para 1 text.\n\nPara 2 text.\n\nPara 3 text.'
    const citations = [
      createMockCitation(5, 10),   // Para 1
      createMockCitation(20, 25),  // Para 2
      createMockCitation(35, 40)   // Para 3
    ]

    const map = detectParagraphBoundaries(text, citations)

    expect(map.get(0)).toBe(0)  // First citation in para 0
    expect(map.get(1)).toBe(1)  // Second citation in para 1
    expect(map.get(2)).toBe(2)  // Third citation in para 2
  })

  it('assigns all citations to same paragraph if no boundaries', () => {
    const text = 'Single paragraph with multiple citations.'
    const citations = [
      createMockCitation(0, 5),
      createMockCitation(10, 15),
      createMockCitation(20, 25)
    ]

    const map = detectParagraphBoundaries(text, citations)

    expect(map.get(0)).toBe(0)
    expect(map.get(1)).toBe(0)
    expect(map.get(2)).toBe(0)
  })
})

describe('isWithinBoundary', () => {
  it('returns true for same paragraph with paragraph strategy', () => {
    const map = new Map([[0, 0], [1, 0]])  // Both in para 0
    expect(isWithinBoundary(0, 1, map, 'paragraph')).toBe(true)
  })

  it('returns false for different paragraphs with paragraph strategy', () => {
    const map = new Map([[0, 0], [1, 1]])  // Different paras
    expect(isWithinBoundary(0, 1, map, 'paragraph')).toBe(false)
  })

  it('returns true for none strategy', () => {
    const map = new Map([[0, 0], [1, 10]])  // Very different paras
    expect(isWithinBoundary(0, 1, map, 'none')).toBe(true)
  })

  it('returns true for section strategy within same section', () => {
    const map = new Map([[0, 0], [1, 2]])  // Paras 0 and 2 = same section (0-2)
    expect(isWithinBoundary(0, 1, map, 'section')).toBe(true)
  })
})
```

**Part D: Create Levenshtein tests (tests/unit/resolve/levenshtein.test.ts)**

```typescript
import { describe, it, expect } from 'vitest'
import { levenshteinDistance, normalizedLevenshteinDistance } from '@/resolve/levenshtein'

describe('levenshteinDistance', () => {
  it('returns 0 for identical strings', () => {
    expect(levenshteinDistance('Smith', 'Smith')).toBe(0)
  })

  it('calculates single character insertion', () => {
    expect(levenshteinDistance('Smith', 'Smiths')).toBe(1)
  })

  it('calculates single character deletion', () => {
    expect(levenshteinDistance('Smiths', 'Smith')).toBe(1)
  })

  it('calculates single character substitution', () => {
    expect(levenshteinDistance('Smith', 'Smyth')).toBe(1)
  })

  it('handles completely different strings', () => {
    expect(levenshteinDistance('abc', 'xyz')).toBe(3)
  })
})

describe('normalizedLevenshteinDistance', () => {
  it('returns 1.0 for identical strings', () => {
    expect(normalizedLevenshteinDistance('Smith', 'Smith')).toBe(1.0)
  })

  it('returns high similarity for minor differences', () => {
    const similarity = normalizedLevenshteinDistance('Smith Inc.', 'Smith')
    expect(similarity).toBeGreaterThan(0.7)
  })

  it('is case insensitive', () => {
    expect(normalizedLevenshteinDistance('SMITH', 'smith')).toBe(1.0)
  })

  it('returns low similarity for very different strings', () => {
    const similarity = normalizedLevenshteinDistance('Smith', 'Johnson')
    expect(similarity).toBeLessThan(0.3)
  })
})
```

Export all functions.
  </action>
  <verify>npm test tests/unit/resolve/scopeBoundary.test.ts tests/unit/resolve/levenshtein.test.ts passes all tests</verify>
  <done>Paragraph boundary detection, scope validation, and Levenshtein distance implemented with comprehensive tests</done>
</task>

<task type="auto">
  <name>Task 3: Implement DocumentResolver with full resolution logic and resolveCitations wrapper</name>
  <files>src/resolve/DocumentResolver.ts, src/resolve/index.ts</files>
  <action>
**Part A: Implement DocumentResolver with ALL resolution methods (src/resolve/DocumentResolver.ts)**

Follow RESEARCH.md Pattern 1, implementing resolveSupra() and resolveShortFormCase():

```typescript
import type { Citation, IdCitation, SupraCitation, ShortFormCaseCitation, CaseCitation } from '../types'
import type { ResolutionOptions, ResolutionResult, ResolutionContext, ResolvedCitation } from './types'
import { detectParagraphBoundaries, isWithinBoundary } from './scopeBoundary'
import { normalizedLevenshteinDistance } from './levenshtein'

/**
 * Document-scoped citation resolver.
 * Each document gets a fresh instance to prevent state leakage.
 */
export class DocumentResolver {
  private citations: Citation[]
  private options: ResolutionOptions
  private context: ResolutionContext

  constructor(
    citations: Citation[],
    text: string = '',
    options: Partial<ResolutionOptions> = {}
  ) {
    this.citations = citations
    this.options = {
      scopeStrategy: 'paragraph',
      autoDetectParagraphs: true,
      paragraphBoundaryPattern: /\n\n+/,
      fuzzyPartyMatching: true,
      partyMatchThreshold: 0.8,
      allowNestedResolution: false,
      reportUnresolved: true,
      ...options
    }

    this.context = {
      citationIndex: 0,
      allCitations: [],
      lastFullCitation: null,
      fullCitationHistory: [],
      paragraphMap: this.options.autoDetectParagraphs && text
        ? detectParagraphBoundaries(text, citations, this.options.paragraphBoundaryPattern)
        : undefined
    }
  }

  /**
   * Resolve all citations in document.
   * Returns new array with resolution field added.
   */
  resolve(): ResolvedCitation[] {
    const results: ResolvedCitation[] = []

    for (let i = 0; i < this.citations.length; i++) {
      const citation = this.citations[i]
      this.context.citationIndex = i
      this.context.allCitations.push(citation)

      // Track full citations for antecedent history
      if (this.isFullCitation(citation)) {
        this.context.lastFullCitation = citation
        this.context.fullCitationHistory.push(citation)
        results.push(citation)  // Full citations don't resolve
        continue
      }

      // Resolve short-form citations
      const resolution = this.resolveCitation(citation)
      results.push({
        ...citation,
        resolution
      })
    }

    return results
  }

  private resolveCitation(citation: Citation): ResolutionResult {
    if (citation.type === 'id') {
      return this.resolveId(citation as IdCitation)
    }

    if (citation.type === 'supra') {
      return this.resolveSupra(citation as SupraCitation)
    }

    if (citation.type === 'shortFormCase') {
      return this.resolveShortFormCase(citation as ShortFormCaseCitation)
    }

    return {
      warnings: [],
      failureReason: 'Unknown citation type for resolution'
    }
  }

  private resolveId(idCitation: IdCitation): ResolutionResult {
    if (!this.context.lastFullCitation) {
      return {
        failureReason: 'No preceding full citation within scope',
        warnings: this.options.reportUnresolved
          ? [{ level: 'warning', message: 'Id. citation has no antecedent' }]
          : []
      }
    }

    // Check scope boundary
    const lastFullIndex = this.context.allCitations.indexOf(this.context.lastFullCitation)
    const currentIndex = this.context.citationIndex

    if (this.context.paragraphMap && !isWithinBoundary(
      lastFullIndex,
      currentIndex,
      this.context.paragraphMap,
      this.options.scopeStrategy
    )) {
      return {
        failureReason: 'Antecedent outside scope boundary (paragraph)',
        warnings: this.options.reportUnresolved
          ? [{ level: 'warning', message: 'Id. citation antecedent exceeds paragraph scope' }]
          : []
      }
    }

    return {
      resolvedTo: this.context.lastFullCitation,
      confidence: 1.0,
      warnings: []
    }
  }

  private resolveSupra(supraCitation: SupraCitation): ResolutionResult {
    if (this.context.fullCitationHistory.length === 0) {
      return {
        failureReason: 'No full citations in document history',
        warnings: this.options.reportUnresolved
          ? [{ level: 'warning', message: 'Supra citation has no antecedent history' }]
          : []
      }
    }

    // Search history for party name match
    const partyName = supraCitation.partyName.toLowerCase()
    let bestMatch: Citation | null = null
    let bestScore = 0

    for (let i = this.context.fullCitationHistory.length - 1; i >= 0; i--) {
      const candidate = this.context.fullCitationHistory[i]

      // Only case citations have party names
      if (candidate.type !== 'case') continue

      const caseCitation = candidate as CaseCitation
      const candidateName = caseCitation.caseName?.toLowerCase() || ''

      if (this.options.fuzzyPartyMatching) {
        // Fuzzy match using Levenshtein distance
        const similarity = normalizedLevenshteinDistance(partyName, candidateName)
        if (similarity >= this.options.partyMatchThreshold && similarity > bestScore) {
          bestScore = similarity
          bestMatch = candidate
        }
      } else {
        // Exact match
        if (candidateName.includes(partyName)) {
          bestMatch = candidate
          break  // Most recent exact match wins
        }
      }
    }

    if (!bestMatch) {
      return {
        failureReason: `No case with party name matching "${supraCitation.partyName}"`,
        warnings: this.options.reportUnresolved
          ? [{ level: 'warning', message: `Supra citation "${supraCitation.partyName}" has no matching antecedent` }]
          : []
      }
    }

    return {
      resolvedTo: bestMatch,
      confidence: bestScore || 1.0,
      warnings: []
    }
  }

  private resolveShortFormCase(shortFormCitation: ShortFormCaseCitation): ResolutionResult {
    if (this.context.fullCitationHistory.length === 0) {
      return {
        failureReason: 'No full citations in document history',
        warnings: this.options.reportUnresolved
          ? [{ level: 'warning', message: 'Short-form citation has no antecedent history' }]
          : []
      }
    }

    // Search history for volume/reporter match (most recent wins per CONTEXT.md)
    for (let i = this.context.fullCitationHistory.length - 1; i >= 0; i--) {
      const candidate = this.context.fullCitationHistory[i]

      if (candidate.type !== 'case') continue

      const caseCitation = candidate as CaseCitation

      if (
        caseCitation.volume === shortFormCitation.volume &&
        caseCitation.reporter === shortFormCitation.reporter
      ) {
        return {
          resolvedTo: candidate,
          confidence: 0.9,  // High confidence for volume/reporter match
          warnings: []
        }
      }
    }

    return {
      failureReason: `No case with volume ${shortFormCitation.volume} ${shortFormCitation.reporter}`,
      warnings: this.options.reportUnresolved
        ? [{ level: 'warning', message: `Short-form citation has no matching antecedent` }]
        : []
    }
  }

  private isFullCitation(citation: Citation): boolean {
    // Full citations: case, statute, journal, neutral, publicLaw, federalRegister
    // NOT: id, supra, shortFormCase
    return (
      citation.type === 'case' ||
      citation.type === 'statute' ||
      citation.type === 'journal' ||
      citation.type === 'neutral' ||
      citation.type === 'publicLaw' ||
      citation.type === 'federalRegister'
    )
  }
}
```

**Part B: Create resolveCitations wrapper (src/resolve/index.ts)**

```typescript
import { DocumentResolver } from './DocumentResolver'
import type { Citation } from '../types'
import type { ResolutionOptions, ResolvedCitation } from './types'

/**
 * Convenience function to resolve citations in a document.
 * Creates DocumentResolver instance and returns resolved citations.
 *
 * @param citations - Array of citations to resolve
 * @param text - Full document text for paragraph boundary detection
 * @param options - Resolution configuration options
 * @returns Array of citations with resolution field added
 *
 * @example
 * ```typescript
 * const citations = extractCitations(text)
 * const resolved = resolveCitations(citations, text, { scopeStrategy: 'paragraph' })
 *
 * for (const cite of resolved) {
 *   if (cite.resolution?.resolvedTo) {
 *     console.log(`${cite.text} → ${cite.resolution.resolvedTo.text}`)
 *   }
 * }
 * ```
 */
export function resolveCitations(
  citations: Citation[],
  text: string = '',
  options?: Partial<ResolutionOptions>
): ResolvedCitation[] {
  const resolver = new DocumentResolver(citations, text, options)
  return resolver.resolve()
}

export { DocumentResolver } from './DocumentResolver'
export type { ResolutionOptions, ResolutionResult, ResolvedCitation } from './types'
```

Export all from src/resolve/index.ts.
  </action>
  <verify>grep "private resolveSupra" src/resolve/DocumentResolver.ts returns method definition, grep "export function resolveCitations" src/resolve/index.ts returns wrapper function</verify>
  <done>DocumentResolver implements full resolution for Id./supra/short-form citations with Levenshtein matching, resolveCitations wrapper provides convenient API</done>
</task>

</tasks>

<verification>
1. npm run typecheck passes
2. npm test passes all scope boundary and Levenshtein tests
3. DocumentResolver class exports from src/resolve/index.ts
4. resolveCitations wrapper function exports from src/resolve/index.ts
5. ResolutionOptions, ResolutionResult types available
6. detectParagraphBoundaries correctly maps citations to paragraphs
7. isWithinBoundary enforces paragraph/section/none strategies
8. Levenshtein distance calculates correctly for party name matching
9. resolveSupra(), resolveShortFormCase() methods exist in DocumentResolver
</verification>

<success_criteria>
- DocumentResolver implements document-scoped resolution with state tracking
- Id./supra/short-form resolution fully implemented (not stubbed)
- Levenshtein distance for fuzzy party name matching implemented
- Paragraph boundary detection from text implemented
- Scope configurable (paragraph, section, none)
- Immutable results via object spread
- resolveCitations wrapper provides convenient API
- Ready for integration testing (Plan 04)
</success_criteria>

<output>
After completion, create `.planning/phases/04-short-form-resolution/04-03-SUMMARY.md`
</output>
